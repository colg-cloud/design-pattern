/**
 * 单例模式 （三）
 * 
 * <pre>
 * 当第一次调用getLoadBalancer()方法创建并启动负载均衡器时，instance对象为null值，
 * 因此系统将执行代码instance = new LoadBalancer()，在此过程中，由于要对LoadBalancer进行大量初始化工作，需要一段时间来创建LoadBalancer对象。
 * 而在此时，如果再一次调用getLoadBalancer()方法（通常发生在多线程环境中），由于instance尚未创建成功，仍为null值，判断条件(instance== null)为真值，
 * 因此代码instance= new LoadBalancer()将再次执行，导致最终创建了多个instance对象，这违背了单例模式的初衷，也导致系统运行发生错误。
 * 
 * 饿汉式单例类与懒汉式单例类比较
 * 
 *  饿汉式单例类
 *  在类被加载时就将自己实例化，它的优点在于无须考虑多线程访问问题，可以确保实例的唯一性；
 *  从调用速度和反应时间角度来讲，由于单例对象一开始就得以创建，因此要优于懒汉式单例。
 *  但是无论系统在运行时是否需要使用该单例对象，由于在类加载时该对象就需要创建，因此从资源利用效率角度来讲，饿汉式单例不及懒汉式单例，
 *  而且在系统加载时由于需要创建饿汉式单例对象，加载时间可能会比较长。
 *  
 *  懒汉式单例类
 *  在第一次使用时创建，无须一直占用系统资源，实现了延迟加载，但是必须处理好多个线程同时访问的问题，
 *  特别是当单例类作为资源控制器，在实例化时必然涉及资源初始化，而资源初始化很有可能耗费大量时间，
 *  这意味着出现多线程同时首次引用此类的机率变得较大，需要通过双重检查锁定等机制进行控制，这将导致系统性能受到一定影响。
 * </pre>
 *
 * @author colg
 */
package cn.colg.example._03;